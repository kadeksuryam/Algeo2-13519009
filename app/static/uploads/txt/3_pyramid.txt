Dump of assembler code for function Pyramid:
   0x00000e20 <+0>:     push   %ebx
   0x00000e21 <+1>:     sub    $0x18,%esp
   0x00000e24 <+4>:     call   0xad0 <__x86.get_pc_thunk.bx>	# ASLR Setup
   0x00000e29 <+9>:     add    $0x4137,%ebx
   0x00000e2f <+15>:    mov    %gs:0x14,%eax			# Stack buffer overflow protection
   0x00000e35 <+21>:    mov    %eax,0xc(%esp)
   0x00000e39 <+25>:    xor    %eax,%eax

	--- sscanf call ---
   0x00000e3b <+27>:    lea    0x8(%esp),%eax
   0x00000e3f <+31>:    push   %eax
   0x00000e40 <+32>:    lea    0x8(%esp),%eax
   0x00000e44 <+36>:    push   %eax
   0x00000e45 <+37>:    lea    -0x23a9(%ebx),%eax               (from ida "%d %d")
   0x00000e4b <+43>:    push   %eax                             ?! expect 2 array again i guess
   0x00000e4c <+44>:    pushl  0x2c(%esp)			input
   0x00000e50 <+48>:    call   0x9b0 <__isoc99_sscanf@plt>	sscanf(input,"%d %d",&a, &b)
   0x00000e55 <+53>:    add    $0x10,%esp

	2 argument check
   0x00000e58 <+56>:    cmp    $0x1,%eax
   ** 0x00000e5b <+59>:    jle    0xe77 <Pyramid+87>            !! must eax > 1
   0x00000e5d <+61>:    cmpl   $0x7,0x4(%esp)                   !! from i f, esp is argument count, *(esp+1) is first arg, *(esp+2) is second arg
   ** 0x00000e62 <+66>:    ja     0xefb <Pyramid+219>           !! default case,  0x4(%esp) <= 7 unsign cast     
   0x00000e68 <+72>:    mov    0x4(%esp),%eax                   !! eax = first arg

	if not default case, prepare for jump table
   0x00000e6c <+76>:    mov    %ebx,%edx
   0x00000e6e <+78>:    add    -0x26c0(%ebx,%eax,4),%edx        !! edx = jumptable + first arg
   0x00000e75 <+85>:    jmp    *%edx                            !! Jump table





   !! failure argument <= 1
   ** 0x00000e77 <+87>:    call   0x1538 <bad_instruction>
   0x00000e7c <+92>:    jmp    0xe5d <Pyramid+61>




   0x00000e7e <+94>:    mov    $0x1e5,%eax		<---- case 0
   0x00000e83 <+99>:    jmp    0xe8a <Pyramid+106>

   0x00000e85 <+101>:   mov    $0x0,%eax		<---- case 1
   0x00000e8a <+106>:   sub    $0x3cb,%eax

   case 2   0x00000e8f <+111>:   add    $0x37e,%eax
   case 3   0x00000e94 <+116>:   sub    $0x2b9,%eax
   case 4   0x00000e99 <+121>:   add    $0x2b9,%eax
   case 5   0x00000e9e <+126>:   sub    $0x2b9,%eax

   cant do this
   case 6   0x00000ea3 <+131>:   add    $0x2b9,%eax
   case 7   0x00000ea8 <+136>:   sub    $0x2b9,%eax

   0x00000ead <+141>:   cmpl   $0x5,0x4(%esp)       !! must 0x4(%esp) <= 5
   ** 0x00000eb2 <+146>:   jg     0xeba <Pyramid+154>
   0x00000eb4 <+148>:   cmp    %eax,0x8(%esp)
   0x00000eb8 <+152>:   je     0xebf <Pyramid+159>          <-- target

   ** 0x00000eba <+154>:   call   0x1538 <bad_instruction>



            --- exit sequence ---
   0x00000ebf <+159>:   mov    0xc(%esp),%eax
   0x00000ec3 <+163>:   xor    %gs:0x14,%eax
   # 0x00000eca <+170>:   jne    0xf07 <Pyramid+231>
   0x00000ecc <+172>:   add    $0x18,%esp
   0x00000ecf <+175>:   pop    %ebx
   0x00000ed0 <+176>:   ret



	--- jump table ---
    kekw ida identified switch 8 cases
   0x00000ed1 <+177>:   mov    $0x0,%eax            case 2
   0x00000ed6 <+182>:   jmp    0xe8f <Pyramid+111>

   0x00000ed8 <+184>:   mov    $0x0,%eax            case 3
   0x00000edd <+189>:   jmp    0xe94 <Pyramid+116>

   0x00000edf <+191>:   mov    $0x0,%eax            case 4    !! using 4 6, jumped here
   0x00000ee4 <+196>:   jmp    0xe99 <Pyramid+121>

   0x00000ee6 <+198>:   mov    $0x0,%eax            case 5
   0x00000eeb <+203>:   jmp    0xe9e <Pyramid+126>

   0x00000eed <+205>:   mov    $0x0,%eax            case 6
   0x00000ef2 <+210>:   jmp    0xea3 <Pyramid+131>

   0x00000ef4 <+212>:   mov    $0x0,%eax            case 7
   0x00000ef9 <+217>:   jmp    0xea8 <Pyramid+136>


   !! failure / default case
   ** 0x00000efb <+219>:   call   0x1538 <bad_instruction>
   0x00000f00 <+224>:   mov    $0x0,%eax
   0x00000f05 <+229>:   jmp    0xead <Pyramid+141>



   0x00000f07 <+231>:   call   0x24d0 <__stack_chk_fail_local>
