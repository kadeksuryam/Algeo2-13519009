Dump of assembler code for function TerminalDogma:
   0x00001027 <+0>:     push   %ebp
   0x00001028 <+1>:     push   %edi
   0x00001029 <+2>:     push   %esi
   0x0000102a <+3>:     push   %ebx
   0x0000102b <+4>:     sub    $0x54,%esp
   0x0000102e <+7>:     call   0xad0 <__x86.get_pc_thunk.bx>
   0x00001033 <+12>:    add    $0x3f2d,%ebx
   0x00001039 <+18>:    mov    %gs:0x14,%eax
   0x0000103f <+24>:    mov    %eax,0x44(%esp)
   0x00001043 <+28>:    xor    %eax,%eax
                --- end of setup ---

                --- function body ---
   0x00001045 <+30>:    lea    0x14(%esp),%eax
   0x00001049 <+34>:    push   %eax
   0x0000104a <+35>:    pushl  0x6c(%esp)
   0x0000104e <+39>:    call   0x160e <read_six_numbers>                        # read_six_numbers(array,input)
   0x00001053 <+44>:    add    $0x10,%esp
   0x00001056 <+47>:    mov    $0x0,%ebp                        ebp use as counter = 0

                    ??? wait a second, why ebp used as register? suspicious
                    --- first loop ---
   0x0000105b <+52>:    mov    0xc(%esp,%ebp,4),%eax                    <---------|      eax = array[counter]
   0x0000105f <+56>:    sub    $0x1,%eax                                          |       !!!I1 then array[counter] must be on [1,6]
   0x00001062 <+59>:    cmp    $0x5,%eax                                          |      eax <= 5
   ** 0x00001065 <+62>:    ja     0x1077 <TerminalDogma+80>                       |     <-- then it should below 5
   0x00001067 <+64>:    add    $0x1,%ebp                                          |         counter++;
   0x0000106a <+67>:    cmp    $0x6,%ebp                                          |         if counter == 6 jump to 157
   0x0000106d <+70>:    je     0x10c4 <TerminalDogma+157>                         |     <<<<<N2 exit to 157
   0x0000106f <+72>:    mov    %ebp,%esi                                          |         tpct = counter
   0x00001071 <+74>:    lea    0xc(%esp),%edi                                     |       edi = *1st
   0x00001075 <+78>:    jmp    0x1086 <TerminalDogma+95>                          |
                                                                                  |
                                                                                  |
   ** 0x00001077 <+80>:    call   0x1538 <bad_instruction>                        |
   0x0000107c <+85>:    jmp    0x1067 <TerminalDogma+64>                          |
                                                                                  |
        --- sub loop ---                                                          |
   0x0000107e <+87>:    add    $0x1,%esi                <-------|                 | tpct++
   0x00001081 <+90>:    cmp    $0x5,%esi                        |                 | if tpct >= 6 back to core loop
   0x00001084 <+93>:    jg     0x105b <TerminalDogma+52>        |          >------|
   0x00001086 <+95>:    mov    (%edi,%esi,4),%eax               |           <==== unconditional jump from 78, eax = array[tpct]
   0x00001089 <+98>:    cmp    %eax,-0x4(%edi,%ebp,4)           | >> do this eax != -0x4(%edi,%ebp,4)///// !!!I2 array[counter-1] != array[tpct]
   0x0000108d <+102>:   jne    0x107e <TerminalDogma+87>    >---|           !!!I3 TL;DR this section is loop for checking uniqueness on first loop

        ######## possible code
        unsigned int i = 0
        while (1) {
            if ((unsigned) (array[i] - 1) > 5)
                bad_instruction();
            i++;
            if (i == 6)
                break;
            for (int j = i ; j < 6 ; j++)
                if (array[i-1] == array[j])
                    bad_instruction();
        }

        !!! input must be permutation of 1 2 3 4 5 6


   ** 0x0000108f <+104>:   call   0x1538 <bad_instruction>
   0x00001094 <+109>:   jmp    0x107e <TerminalDogma+87>


        --- loop again kekw ---
                            --- sub loop again ---
   0x00001096 <+111>:   mov    0x8(%edx),%edx       <=== case if jg, edx += 8       edx???
   0x00001099 <+114>:   add    $0x1,%eax                    temp++
   0x0000109c <+117>:   cmp    %ecx,%eax                    array[counter] != temp
   0x0000109e <+119>:   jne    0x1096 <TerminalDogma+111>

   0x000010a0 <+121>:   mov    %edx,0x24(%esp,%edi,4) <=== instruction below if
   0x000010a4 <+125>:   add    $0x1,%esi                                i++
   0x000010a7 <+128>:   cmp    $0x6,%esi                                if i == 6 break
   0x000010aa <+131>:   je     0x10cb <TerminalDogma+164> <<<<<N3 do this to escape loop and advance

   0x000010ac <+133>:   mov    %esi,%edi                        <-------|           edi = counter
   0x000010ae <+135>:   mov    0xc(%esp,%esi,4),%ecx                    |           ecx = array[i]
   0x000010b2 <+139>:   mov    $0x1,%eax                                |           temp = 1
   0x000010b7 <+144>:   lea    0x598(%ebx),%edx                         |           memory       ??????? from debug ebx = 4214624, so 4216056
   0x000010bd <+150>:   cmp    $0x1,%ecx                                |           if array[i] > 1
   0x000010c0 <+153>:   jg     0x1096 <TerminalDogma+111>               |
   0x000010c2 <+155>:   jmp    0x10a0 <TerminalDogma+121>               |
                                                                        |
   0x000010c4 <+157>:   mov    $0x0,%esi                                |              <==== conditional jump from 70, i = 0
   0x000010c9 <+162>:   jmp    0x10ac <TerminalDogma+133>               |
                ##### possible code

            i = 0;
            address = ???;
            do {
                temp = 1;
                if (array[i] > 1)
                    do {
                        address = *(address+2);
                        temp++;
                    } while (array[i] != temp);
                node[i] = address;
                i++;
            } while (i != 6);

            ???? %esp+0x24 < array stored value

        input 3 5 4 6 1 2
        0x405504 -> 171,
        4216080 -> 676,
        4216104 -> 164,
        4216092 -> 244,
        4216056 -> 775,
        4214912 -> 469

        3 1 4 6 5 2
        4216080 -> 676,
        4216056 -> 775,
        4216092 -> 244,
        4214912 -> 469,
        4216104 -> 164,
        4216068 -> 171

        5 2 4 6 3 1 <<<<< key



        1 2 3 4 5 6
        4216056 -> 775,

        4214912 -> 469,

        with input 1 2 3 4 5 6
        421
        6056 6068 6080 6092 6104 4912
        ???? array of pointer???

        --- continuation function body ---
   0x000010cb <+164>:   mov    0x24(%esp),%esi      val[0]
   0x000010cf <+168>:   mov    0x28(%esp),%eax      val[1]
   0x000010d3 <+172>:   mov    %eax,0x8(%esi)                   *(val[0]+2) = val[1]
   0x000010d6 <+175>:   mov    0x2c(%esp),%edx      val[2]
   0x000010da <+179>:   mov    %edx,0x8(%eax)                   *(val[1]+2) = val[2]
   0x000010dd <+182>:   mov    0x30(%esp),%eax      val[3]
   0x000010e1 <+186>:   mov    %eax,0x8(%edx)                   *(val[2]+2) = val[3]
   0x000010e4 <+189>:   mov    0x34(%esp),%edx      val[4]
   0x000010e8 <+193>:   mov    %edx,0x8(%eax)                   *(val[3]+2) = val[4]
   0x000010eb <+196>:   mov    0x38(%esp),%eax      val[5]
   0x000010ef <+200>:   mov    %eax,0x8(%edx)                   *(val[4]+2) = val[5]
   0x000010f2 <+203>:   movl   $0x0,0x8(%eax)                   *(val[5]+2) = 0
   0x000010f9 <+210>:   mov    $0x5,%edi                        edi = counter = 5
   0x000010fe <+215>:   jmp    0x1108 <TerminalDogma+225>

   esi still val[0]
                                                !!! let k = 0 from unconditional jump 215
                    --- loop again ---
   0x00001100 <+217>:   mov    0x8(%esi),%esi                                       <----------|    esi = *(val[k]+2)
   0x00001103 <+220>:   sub    $0x1,%edi            thus edi == 1                              |    counter == 0 then done
   0x00001106 <+223>:   je     0x1118 <TerminalDogma+241> <<<<<N4 do this                      |
                                                                                               |
   0x00001108 <+225>:   mov    0x8(%esi),%eax            <=== unconditional jump from 215      |        eax = *(val[k]+2)
   0x0000110b <+228>:   mov    (%eax),%eax                                                     |        eax = *eax
   0x0000110d <+230>:   cmp    %eax,(%esi)          must be eax <= *esi                        |        **(val[k]+2) <= *(val[k])
   0x0000110f <+232>:   jle    0x1100 <TerminalDogma+217>                             >--------|

   ##### possible code
   k = 0;
   counter = 5;
   do {
       if (**(val[k]+2) > *(val[k]))
            bad_instruction();
       counter--;
   } while (i != 0);



   ** 0x00001111 <+234>:   call   0x1538 <bad_instruction>
   0x00001116 <+239>:   jmp    0x1100 <TerminalDogma+217>




	--- target ---
   0x00001118 <+241>:   mov    0x3c(%esp),%eax
   0x0000111c <+245>:   xor    %gs:0x14,%eax
   0x00001123 <+252>:   jne    0x112d <TerminalDogma+262>
   0x00001125 <+254>:   add    $0x4c,%esp
   0x00001128 <+257>:   pop    %ebx
   0x00001129 <+258>:   pop    %esi
   0x0000112a <+259>:   pop    %edi
   0x0000112b <+260>:   pop    %ebp
   0x0000112c <+261>:   ret
   0x0000112d <+262>:   call   0x24d0 <__stack_chk_fail_local>
