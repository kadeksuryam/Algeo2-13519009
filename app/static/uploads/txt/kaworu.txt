Dump of assembler code for function kaworu:
   0x00001185 <+0>:     push   %esi
   0x00001186 <+1>:     push   %ebx
   0x00001187 <+2>:     sub    $0x4,%esp
   0x0000118a <+5>:     call   0xad0 <__x86.get_pc_thunk.bx>
   0x0000118f <+10>:    add    $0x3dd1,%ebx
   0x00001195 <+16>:    call   0x1658 <read_line>       <<< input
   0x0000119a <+21>:    sub    $0x4,%esp


   0x0000119d <+24>:    push   $0xa         << base
   0x0000119f <+26>:    push   $0x0         << endptr
   0x000011a1 <+28>:    push   %eax         << str from readline
   0x000011a2 <+29>:    call   0xa30 <strtol@plt>

   0x000011a7 <+34>:    mov    %eax,%esi            return save to esi
   0x000011a9 <+36>:    lea    -0x1(%eax),%eax
   0x000011ac <+39>:    add    $0x10,%esp

   0x000011af <+42>:    cmp    $0x3e8,%eax          must unsign eax < 0x3E8 this is 1000
   **0x000011b4 <+47>:    ja     0x11ed <kaworu+104>
   0x000011b6 <+49>:    sub    $0x8,%esp
   0x000011b9 <+52>:    push   %esi                 input integer save
   0x000011ba <+53>:    lea    0x544(%ebx),%eax             first call is 0x4054A4 with value 36
   0x000011c0 <+59>:    push   %eax
   0x000011c1 <+60>:    call   0x1132 <fun7>            << eax carrying &array[0]
            therefore fun(&array[0],inputinteger)
   0x000011c6 <+65>:    add    $0x10,%esp


   0x000011c9 <+68>:    cmp    $0x3,%eax        must eax == 3 or fun7 return is 3 <<<<<<< how???
   0x000011cc <+71>:    je     0x11d3 <kaworu+78>

   **0x000011ce <+73>:    call   0x1538 <bad_instruction>

   0x000011d3 <+78>:    sub    $0xc,%esp
   0x000011d6 <+81>:    lea    -0x2748(%ebx),%eax
   0x000011dc <+87>:    push   %eax
   0x000011dd <+88>:    call   0x960 <puts@plt>
   0x000011e2 <+93>:    call   0x178b <sector_repaired>
   0x000011e7 <+98>:    add    $0x14,%esp
   0x000011ea <+101>:   pop    %ebx
   0x000011eb <+102>:   pop    %esi
   0x000011ec <+103>:   ret



   **0x000011ed <+104>:   call   0x1538 <bad_instruction>
   0x000011f2 <+109>:   jmp    0x11b6 <kaworu+49>



   first call is 0x4054A4 with value 36
   first item -> 36
   36 8 x 22 x 35

   this one of them should work
      +1 +2         +4
   36 8  50 6 22 45 107 20 35 40 47 1 7 99 101
   36 8 50 22 45 6 107
   107 <<<< correct


   Dump of assembler code for function fun7:
   0x00001132 <+0>:     push   %ebx
   0x00001133 <+1>:     sub    $0x8,%esp
   0x00001136 <+4>:     mov    0x10(%esp),%edx      << address of 1st
   0x0000113a <+8>:     mov    0x14(%esp),%ecx      << input or 2nd

   0x0000113e <+12>:    test   %edx,%edx        edx cant be zero
   **0x00001140 <+14>:    je     0x117e <fun7+76>

   0x00001142 <+16>:    mov    (%edx),%ebx
   0x00001144 <+18>:    cmp    %ecx,%ebx        if 1st > 2nd rcall 1
   0x00001146 <+20>:    jg     0x1156 <fun7+36>

   0x00001148 <+22>:    mov    $0x0,%eax        result = 0
   0x0000114d <+27>:    cmp    %ecx,%ebx        if ebx != ecx rcall 2
   0x0000114f <+29>:    jne    0x1169 <fun7+55>



            --------------------
   0x00001151 <+31>:    add    $0x8,%esp
   0x00001154 <+34>:    pop    %ebx
   0x00001155 <+35>:    ret
        -------- exit ----------

        int fun7(&p1,p2) {
            if (p1 == NULL)
                return -1;
            else if (*p1 > p2)
                return 2*fun7(p1+1,p2);
            else if (*p1 != p2)
                return 2*fun7(p1+2,p2) + 1;
        }


            --- rcall 1 ---
   0x00001156 <+36>:    sub    $0x8,%esp
   0x00001159 <+39>:    push   %ecx
   0x0000115a <+40>:    pushl  0x4(%edx)
   0x0000115d <+43>:    call   0x1132 <fun7>            fun7(,input)
   0x00001162 <+48>:    add    $0x10,%esp

   0x00001165 <+51>:    add    %eax,%eax                result *= 2
   0x00001167 <+53>:    jmp    0x1151 <fun7+31>


            --- rcall 2 ---
   0x00001169 <+55>:    sub    $0x8,%esp
   0x0000116c <+58>:    push   %ecx
   0x0000116d <+59>:    pushl  0x8(%edx)
   0x00001170 <+62>:    call   0x1132 <fun7>             fun7(,input)
   0x00001175 <+67>:    add    $0x10,%esp

   0x00001178 <+70>:    lea    0x1(%eax,%eax,1),%eax        result = result*2 + 1
   0x0000117c <+74>:    jmp    0x1151 <fun7+31>



   0x0000117e <+76>:    mov    $0xffffffff,%eax     return 0xffffffff
   0x00001183 <+81>:    jmp    0x1151 <fun7+31>
